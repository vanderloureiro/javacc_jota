PARSER_BEGIN(Jota)

import java.io.*;

public class Jota {

    public static void main(String args[]) throws ParseException, IOException {

        Jota lex = new Jota(new FileInputStream(args[0]));
        lex.Jota();
    }
}

PARSER_END(Jota)

SKIP: {
    " " | "\t" | "\n" | "\r"
}

TOKEN : {
    <PUBLIC: "public">
    | <CLASS: "class">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <EXTENDS: "extends">
    | <OBRACKET: "[">
    | <CBRACKET: "]">
    | <OBRACES: "{">
    | <CBRACES: "}">
    | <OPARENTHESES: "(">
    | <CPARENTHESES: ")">
    | <RETURN: "return">
    | <THIS: "this">
    | <NEW: "new">
    | <TRUE: "true">
    | <FALSE: "false">
    | <DENIAL: "!">
    | <AND: "&&">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <BOOLEAN: "boolean">
    | <INT: "int">
    | <SYSOUT: "System.out.println">
    | <ASSIGNMENT: "=">
    | <LESSTHAN: "<">
    | <PLUS: "+">
    | <MINUS: "-">
    | <MULTIPLIED: "*">
    | <SEMICOLON: ";">
    | <COMMA: ",">
    | <DOT: ".">
    | <LENGTH: "length">
    | <INTEGER_LITERAL: (["0"-"9"])+>
    | <IDENTIFIER: ["a"-"z", "A"-"Z", "_"] ( ["a"-"z", "A"-"Z", "0"-"9", "_" ])* >
}

void Jota(): 
{
    Token t;
}
{
    Structure()
}

void Structure(): 
{} 
{
    MainClass() ( ClassDeclaration() )* <EOF>
}

void MainClass():
{}
{
    <CLASS> Identifier() <OBRACES> 
        <PUBLIC> <STATIC> <VOID> <MAIN> 
            <OPARENTHESES> <STRING> <OBRACKET> <CBRACKET> Identifier() <CPARENTHESES>
        <OBRACES>(Statement())*<CBRACES>
    <CBRACES>
}

void ClassDeclaration():
{}
{
    <CLASS> Identifier() (<EXTENDS> Identifier())? 
        <OBRACES> (VarDeclaration())* (MethodDeclaration())* <CBRACES>
}

void VarDeclaration():
{}
{
    Type() Identifier() <SEMICOLON> 
}

void MethodDeclaration():
{}
{
    <PUBLIC> Type() Identifier() 
    <OPARENTHESES> 
        (Type() Identifier() (<COMMA> Type() Identifier())* )?
    <CPARENTHESES> 
    <OBRACES>
        (LOOKAHEAD(2) VarDeclaration())* (LOOKAHEAD(2) Statement())* <RETURN> Expression() <SEMICOLON>
    <CBRACES>
}

void Type():
{} 
{
    <INT> ArrayType() | <BOOLEAN> | Identifier() 
}

void ArrayType():
{}
{
    (<OBRACKET> <CBRACKET>)? 
}

void Statement():
{
    Token t;
}
{
    <OBRACES>(Statement())*<CBRACES>
    | <IF><OPARENTHESES>Expression()<CPARENTHESES> Statement() <ELSE> Statement()
    | <WHILE> <OPARENTHESES> Expression() <CPARENTHESES> Statement()
    | <SYSOUT> <OPARENTHESES> Expression() <CPARENTHESES> <SEMICOLON>
    | LOOKAHEAD(2) Identifier() <ASSIGNMENT> Expression() <SEMICOLON>
    | LOOKAHEAD(2) Identifier() <OBRACKET> Expression() <CBRACKET> <ASSIGNMENT> Expression() <SEMICOLON>
}

void Expression():
{}
{
    /* Expression() ( <AND> | <LESSTHAN> | <PLUS> | <MINUS> | <MULTIPLIED> ) Expression()
    | Expression() <OBRACKET> Expression() <CBRACKET>
    | Expression() <DOT> <LENGTH>
    | Expression() <DOT> Identifier() <OPARENTHESES> ( Expression() ( <COMMA> Expression() )* )? <CPARENTHESES>
    | */ <INTEGER_LITERAL>
    | <TRUE>
    | <FALSE>
    | Identifier()
    | <THIS>
    | LOOKAHEAD(2) <NEW> <INT> <OBRACKET> Expression() <CBRACKET>
    | LOOKAHEAD(2) <NEW> Identifier() <OPARENTHESES> <CPARENTHESES>
    | <DENIAL> Expression()
    | <OPARENTHESES> Expression() <CPARENTHESES>
}


void Identifier():
{}
{
    <IDENTIFIER> 
}



